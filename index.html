<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Langton's Ant - Fullscreen & Bounce with Decorations</title>
    <style>
      /* 讓整個頁面背景為純黑、並將內容置中 */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background-color: #000; /* 黑色背景 */
        color: #fff;
        text-align: center;
      }
      /* 讓 canvas 置中顯示，並有白色邊框 */
      canvas {
        border: 1px solid #fff;
        display: block;
        margin: 0 auto;
      }
      /* 讓按鈕與輸入欄位排列整齊 */
      button, input {
        margin: 0.5rem;
        padding: 0.5rem 1rem;
        font-size: 1rem;
      }
      input {
        width: 60px;
      }
    </style>
  </head>
  <body>
    <h1>Langton's Ant</h1>
    <!-- 開始按鈕、數字輸入欄位、暫停按鈕 -->
    <button id="startButton">開始</button>
    <input id="antCountInput" type="number" min="1" value="1">
    <button id="pauseButton" style="display:none;">暫停</button>

    <!-- canvas 由 JavaScript 動態設定大小（填滿螢幕 99%） -->
    <canvas id="canvas" style="display:none;"></canvas>

    <script>
      // ========== 全域變數宣告 ==========
      let canvas = document.getElementById('canvas');
      let ctx = canvas.getContext('2d');
      let startButton = document.getElementById('startButton');
      let pauseButton = document.getElementById('pauseButton');
      let antCountInput = document.getElementById('antCountInput');

      // 每個格子的尺寸（以像素為單位）
      let cellSize = 5;
      // cols、rows 為網格的總行數與列數
      let cols, rows;
      // grid 用來存放每格的狀態（0 = 白色邏輯、1 = 黑色邏輯）
      let grid = [];
      // 螞蟻陣列：每隻螞蟻除了位置、方向與隨機步數之外，
      // 還有獨立的 trail 色彩與獨立的裝飾圈屬性：
      // decorationStyle、decorationDiameter 以及 decorationColor
      let ants = [];
      // 模擬計時器 ID
      let simulationInterval;
      // 記錄開始時間（用於色彩漸變）
      let startTime;
      // 控制是否暫停
      let paused = false;

      // ========== 初始化 Canvas 與網格 ==========
      function initCanvas() {
        canvas.width = Math.floor(window.innerWidth * 0.99);
        canvas.height = Math.floor(window.innerHeight * 0.99);
        cols = Math.floor(canvas.width / cellSize);
        rows = Math.floor(canvas.height / cellSize);
        grid = [];
        for (let i = 0; i < cols; i++) {
          grid[i] = [];
          for (let j = 0; j < rows; j++) {
            grid[i][j] = 0;
          }
        }

        // 建立螞蟻物件
        let antCount = parseInt(antCountInput.value);
        if (isNaN(antCount) || antCount < 1) {
          antCount = 1;
        }
        ants = [];
        // 裝飾圈風格選項
        const decorationStyles = ["solid", "dashed", "double", "dotted"];
        for (let i = 0; i < antCount; i++) {
          let newAnt = {
            x: Math.floor(Math.random() * cols),
            y: Math.floor(Math.random() * rows),
            dir: Math.floor(Math.random() * 4),
            randomStepsRemaining: 10,  // 前 10 步採用隨機方向
            // 螞蟻的軌跡顏色（這裡不直接用於裝飾圈）
            color: `hsl(${Math.floor(Math.random() * 360)}, 100%, 50%)`,
            // 隨機挑選一種裝飾圈風格
            decorationStyle: decorationStyles[Math.floor(Math.random() * decorationStyles.length)],
            // 裝飾圈直徑設定為軌跡寬度的2到3倍（隨機介於 10 ~ 15 pixel）
            decorationDiameter: Math.floor((2 + Math.random()) * cellSize),
            // 裝飾圈獨立顏色，採用鮮豔飽和的色彩 (飽和度 100%，亮度 50%)
            decorationColor: `hsl(${Math.floor(Math.random() * 360)}, 100%, 50%)`
          };
          ants.push(newAnt);
        }
      }

      // ========== 漸變色計算（含透明度） ==========
      function getColorForTime() {
        let now = Date.now();
        let elapsedSec = (now - startTime) / 1000;
        let fraction = (elapsedSec % 60) / 60;
        let hue = fraction * 360;
        return `hsla(${hue}, 100%, 50%, 0.5)`;
      }

      // ========== 根據 grid 狀態繪製單一格子 ==========
      function drawCell(i, j) {
        if (grid[i][j] === 1) {
          ctx.fillStyle = getColorForTime();
        } else {
          ctx.fillStyle = '#000';
        }
        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
      }

      // ========== 繪製整個網格 ==========
      function drawGrid() {
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            drawCell(i, j);
          }
        }
      }

      // ========== 繪製單一螞蟻的裝飾圈 ==========
      // 裝飾圈繪製於螞蟻所在格子的中心，直徑為 decorationDiameter，
      // 使用獨立的 decorationColor 及指定的 decorationStyle
      function drawDecoration(ant) {
        let cx = ant.x * cellSize + cellSize / 2;
        let cy = ant.y * cellSize + cellSize / 2;
        let radius = ant.decorationDiameter / 2;
        ctx.strokeStyle = ant.decorationColor;
        switch(ant.decorationStyle) {
          case "solid":
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();
            break;
          case "dashed":
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();
            break;
          case "double":
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cx, cy, radius + 3, 0, 2 * Math.PI);
            ctx.stroke();
            break;
          case "dotted":
            ctx.lineWidth = 2;
            ctx.setLineDash([1, 3]);
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();
            break;
          default:
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();
            break;
        }
      }

      // ========== 繪製所有螞蟻的裝飾圈 ==========
      function drawAllDecorations() {
        ants.forEach(ant => {
          drawDecoration(ant);
        });
      }

      // ========== 模擬邏輯：更新所有螞蟻狀態 ==========
      function update() {
        ants.forEach(ant => {
          let currentColor = grid[ant.x][ant.y];
          // 前 10 步或額外隨機步數：採用隨機方向
          if (ant.randomStepsRemaining > 0) {
            ant.dir = Math.floor(Math.random() * 4);
            ant.randomStepsRemaining--;
          } else {
            // 白格右轉、黑格左轉
            if (currentColor === 0) {
              ant.dir = (ant.dir + 1) % 4;
            } else {
              ant.dir = (ant.dir + 3) % 4;
            }
          }
  
          // 翻轉當前格子的狀態（0 ↔ 1）
          grid[ant.x][ant.y] = 1 - currentColor;
          // 重新繪製該格
          drawCell(ant.x, ant.y);
  
          // 根據方向移動一格
          if (ant.dir === 0) {
            ant.y -= 1;
          } else if (ant.dir === 1) {
            ant.x += 1;
          } else if (ant.dir === 2) {
            ant.y += 1;
          } else if (ant.dir === 3) {
            ant.x -= 1;
          }
  
          // 邊界檢查：若超出範圍則修正位置，並增加 5 步隨機步數
          if (ant.x < 0) {
            ant.x = 0;
            ant.randomStepsRemaining += 5;
          }
          if (ant.x >= cols) {
            ant.x = cols - 1;
            ant.randomStepsRemaining += 5;
          }
          if (ant.y < 0) {
            ant.y = 0;
            ant.randomStepsRemaining += 5;
          }
          if (ant.y >= rows) {
            ant.y = rows - 1;
            ant.randomStepsRemaining += 5;
          }
        });
      }
  
      // ========== 開始模擬 ==========
      function startSimulation() {
        // 隱藏開始按鈕與輸入欄位，顯示暫停按鈕與 canvas
        startButton.style.display = 'none';
        antCountInput.style.display = 'none';
        pauseButton.style.display = 'inline-block';
        canvas.style.display = 'block';
  
        initCanvas();
        drawGrid();
        startTime = Date.now();
  
        simulationInterval = setInterval(() => {
          if (!paused) {
            // 每個 tick 內執行多次更新，再統一重繪裝飾圈
            for (let i = 0; i < 10; i++) {
              update();
            }
            drawAllDecorations();
          }
        }, 50);
      }
  
      // ========== 暫停 / 繼續 ==========
      function togglePause() {
        paused = !paused;
        pauseButton.textContent = paused ? '繼續' : '暫停';
      }
  
      startButton.addEventListener('click', startSimulation);
      pauseButton.addEventListener('click', togglePause);
    </script>
  </body>
</html>
