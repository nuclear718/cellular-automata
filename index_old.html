<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Langton's Ant - Fullscreen & Bounce with Transparency</title>
    <style>
      /* 讓整個頁面背景為純黑、並將內容置中 */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background-color: #000; /* 黑色底 */
        color: #fff;            /* 白色文字，方便在黑底上閱讀 */
        text-align: center;
      }
      /* 讓 canvas 置中顯示，並有白色邊框 */
      canvas {
        border: 1px solid #fff;
        display: block;
        margin: 0 auto;
      }
      /* 讓按鈕略微分行排列，保持整齊 */
      button {
        margin: 0.5rem;
        padding: 0.5rem 1rem;
        font-size: 1rem;
      }
    </style>
  </head>
  <body>
    <h1>Langton's Ant</h1>
    <!-- 開始、暫停按鈕（暫停按鈕在一開始先隱藏） -->
    <button id="startButton">開始</button>
    <button id="pauseButton" style="display:none;">暫停</button>

    <!-- 
      canvas 不指定預設寬高，改由 JavaScript 動態設定，
      以達到「填滿螢幕 99%」的效果
    -->
    <canvas id="canvas" style="display:none;"></canvas>

    <script>
      // ========== 全域變數宣告 ==========

      let canvas = document.getElementById('canvas');
      let ctx = canvas.getContext('2d');
      let startButton = document.getElementById('startButton');
      let pauseButton = document.getElementById('pauseButton');

      // 將螞蟻與軌跡縮小為原本的一半
      let cellSize = 5;  // 原本是 10，改為 5

      // cols、rows 代表網格的總行數與列數
      let cols, rows;

      // 用來存放網格狀態：0 = 白色邏輯、1 = 黑色邏輯
      // （畫面實際顯示時會使用時間漸變色 + 透明度）
      let grid = [];

      // 螞蟻屬性：位置 (x, y) 與方向 dir（0=上、1=右、2=下、3=左）
      let ant = { x: 0, y: 0, dir: 0 };

      // 模擬的計時器 ID
      let simulationInterval;
      // 紀錄開始時間（用於漸變色計算）
      let startTime;
      // 控制是否暫停
      let paused = false;

      // ========== 響應式初始化 ==========

      function initCanvas() {
        // 讓 canvas 實際像素大小為視窗寬高的 99%
        canvas.width = Math.floor(window.innerWidth * 0.99);
        canvas.height = Math.floor(window.innerHeight * 0.99);

        // 計算可容納的網格數量
        cols = Math.floor(canvas.width / cellSize);
        rows = Math.floor(canvas.height / cellSize);

        // 初始化 grid（全部預設為 0）
        grid = [];
        for (let i = 0; i < cols; i++) {
          grid[i] = [];
          for (let j = 0; j < rows; j++) {
            grid[i][j] = 0;
          }
        }

        // 將螞蟻放在網格的隨機位置，並設定隨機方向（0=上、1=右、2=下、3=左）
        ant.x = Math.floor(Math.random() * cols);
        ant.y = Math.floor(Math.random() * rows);
        ant.dir = Math.floor(Math.random() * 4);
      }

      // ========== 漸變色計算（含透明度） ==========

      function getColorForTime() {
        // 計算從開始到現在經過的秒數
        let now = Date.now();
        let elapsedSec = (now - startTime) / 1000;
        // 60 秒為一個週期，取得 [0, 1) 的週期小數
        let fraction = (elapsedSec % 60) / 60;
        // 將 fraction 對應到 0~360 的色相（Hue）
        let hue = fraction * 360;
        // 使用 HSLA，alpha 設定為 0.5（半透明）
        return `hsla(${hue}, 100%, 50%, 0.5)`;
      }

      // ========== 根據 grid 狀態繪製單一格子 ==========

      function drawCell(i, j) {
        // 若 grid[i][j] = 1，則使用「漸變色 + 半透明」；否則用純黑
        if (grid[i][j] === 1) {
          ctx.fillStyle = getColorForTime();
        } else {
          ctx.fillStyle = '#000'; // 與背景同為純黑
        }
        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
      }

      // ========== 一次性繪製整個網格 ==========

      function drawGrid() {
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            drawCell(i, j);
          }
        }
      }

      // ========== 模擬邏輯：更新螞蟻狀態 ==========

      function update() {
        // 1. 根據螞蟻所在格子的顏色決定轉向
        let currentColor = grid[ant.x][ant.y];
        if (currentColor === 0) {
          // 白 -> 右轉
          ant.dir = (ant.dir + 1) % 4;
        } else {
          // 黑 -> 左轉
          ant.dir = (ant.dir + 3) % 4;
        }

        // 2. 翻轉目前格子的狀態（0 -> 1, 1 -> 0）
        grid[ant.x][ant.y] = 1 - currentColor;

        // 3. 重新繪製該格子
        drawCell(ant.x, ant.y);

        // 4. 根據方向移動一格
        if (ant.dir === 0) {
          ant.y -= 1; // 向上
        } else if (ant.dir === 1) {
          ant.x += 1; // 向右
        } else if (ant.dir === 2) {
          ant.y += 1; // 向下
        } else if (ant.dir === 3) {
          ant.x -= 1; // 向左
        }

        // 5. 邊界檢查：若超出範圍則反彈
        if (ant.x < 0) {
          ant.x = 0;
          if (ant.dir === 3) ant.dir = 1;
        }
        if (ant.x >= cols) {
          ant.x = cols - 1;
          if (ant.dir === 1) ant.dir = 3;
        }
        if (ant.y < 0) {
          ant.y = 0;
          if (ant.dir === 0) ant.dir = 2;
        }
        if (ant.y >= rows) {
          ant.y = rows - 1;
          if (ant.dir === 2) ant.dir = 0;
        }
      }

      // ========== 開始模擬 ==========

      function startSimulation() {
        // 隱藏「開始」按鈕
        startButton.style.display = 'none';
        // 顯示「暫停」按鈕
        pauseButton.style.display = 'inline-block';
        // 顯示 canvas
        canvas.style.display = 'block';

        // 初始化畫布與網格
        initCanvas();

        // 繪製初始網格
        drawGrid();

        // 紀錄開始時間，用於色彩漸變
        startTime = Date.now();

        // 啟動計時器：每隔 50 毫秒更新
        simulationInterval = setInterval(() => {
          // 若非暫停狀態才更新
          if (!paused) {
            // 為了加速，每次更新執行多次
            for (let i = 0; i < 10; i++) {
              update();
            }
          }
        }, 50);
      }

      // ========== 暫停 / 繼續 切換 ==========

      function togglePause() {
        paused = !paused;
        // 切換按鈕文字
        pauseButton.textContent = paused ? '繼續' : '暫停';
      }

      // 綁定「開始」按鈕事件
      startButton.addEventListener('click', startSimulation);
      // 綁定「暫停」按鈕事件
      pauseButton.addEventListener('click', togglePause);
    </script>
  </body>
</html>
